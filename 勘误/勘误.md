# 

亲爱的小伙伴:  
感谢您选购和阅读《RISC-V体系结构编程与实践》，感谢您对奔跑吧Linux社区的长期支持！由于我们水平有限，出书时间仓促，难免有不少勘误，我们深感歉意，也恳请大家多多包涵，也欢迎给我们提出批评和建议！我们会不久的将来第2版中继续完善和优化！如果发现有新的勘误或者有好建议，请通过如下方式与我们联系：
邮件：runninglinuxkernel@126.com   
微信公众号：奔跑吧linux社区   
微信号：runninglinuxkernel   
请读者在阅读本书之前，一定要先阅读书最前面的“本书约定”一文。

PDF版本的勘误 下载方法：
关注“奔跑吧linux社区”微信公众号，在微信公众号里输入“risc-v”获取下载地址。

订阅配套视频课程：        
1. 微信打开：https://appv6qgydb09376.h5.xiaoeknow.com      
2. 关注“奔跑吧Linux社区”微信公众号，输入“risc-v”进入在线学习平台    

# 勘误

勘误按照发现的时间为顺序, 其中Fixed表示在第几次印刷中修复了。

| 页码 | 位置 | 原内容                             | 修改后的内容                         | Fixed  |
| ---- | -------- | ---------------------------------- | ------------------------------------ | ------ |
| 375    | 图18.23 | -  | 修改见红色部分   ![](pic/18.23.png) | 3|
|383-384|  注释 | - | 代码45行注释改成：计算C2 <br> 代码56行注释改成：计算C3| 3|
| 386 | 图18.30| - | 图上最上方v9改成v8，如下所示：vfmacc.vf v8, ft2, v2| 3| 
|406| - | hlv{x}.{b\|\|h\|w\|d}{u} rd,  offset(rs1) | b和h之间应该用“\|” | 3|
|411| 图20.16| - | 图中的SGEIP改成SGEIE，VSEIP改成VSEIE | 3|
|427| 图20.21 | - | 图中的imm[11:0] 更正为 imm[11:5] | 3|
|436 | - | 例如，Mem8 addr表示内存地址addr中的8位数据。| Mem8 addr 改成 Mem8(addr) | 3|
| 139| 第8.4章| spec寄存器的值| sepc寄存器的值 | 3|
| 74| - |根据ra寄存器的返回地址，跳转到上一级函数（即func1()函数通过JAR指令调用add_c()函数的下一条指令）。| JAR指令改成JAL指令|3|
| 30| -| 表2.1的信息都可以在NEMU配置菜单中配置。| 表2.1 改成 表2.3| 3|
| 38| 表2.5中第4行| 0b0001  预分频寄存器中的高8位| 0b0001 改成 0b001| 3|
|61| 倒数第二段|在第1行中，交换tp和sscratch寄存器的值，即读取sscratch寄存器的旧值| "交换tp和sscratch寄存器的值"半句去掉| 3| 
| 386| 图18.31| - | 修改见红色加粗部分   ![](pic/18.31.png)| 3|  
| 65| 实验3-3 | 从0x802 0000地址复制32字节到0x8021 0000地址处 | 0x802 0000 改成 0x8020 0000 | 3|
|132| 第二段| mpec：记录发生异常的指令地址。| mpec 改成 mepc| 3|

# 补充

这里列出的不是勘误，是有益的补充，可能会对读者理解有帮助。

| 页码 |   位置   |         原内容    |                补充的内容           | 
| ---- | -------- | ------------------| ------------------------------------|
| 262    | 14.2章 | -  | 在14.2章补充如下内容 <br> <br> LR和SC指令是配对使用，SC指令成功的条件，一是当前保留集有效，二是保留集中包含的数据被成功更新或者写入。无论SC指令执行成功与否，当前CPU包含的保留集都被无效掉。  <br> <br> 有如下情况SC指令会失败。 <br> 1. 如果SC写入的地址，不在与之配对的LR指令组成的保留集范围内。 <br> 2. 如果在LR和SC指令范围内，执行了另外一条SC指令,不管写入任何地址，都会导致SC指令执行失败. <br> 3. 如果在LR和SC指令范围内，执行了另外一条store指令。这相当于是在LR/SC配对的序列中，又插入了一条store指令，并且这条store指令是对LR的加载地址进行store的话，那SC指令会执行失败。如果这条store指令不是对LR加载地址进行store的话，SC指令不会失败。 <br> 4. 如果另外一个CPU对当前LR和SC的保留集地址进行写入操作。<br>  5. 如果另外一个外设（不是CPU）对LR加载的数据进行写入  <br><br> RISC-V架构对LR/SC序列做了一些约束，不符合这些约束的LR/SC序列不能保证在所有RISC-V处理器中都能成功。 <br> 1. LR/SC的循环loop中最多包含16条指令 <br> 2. LR/SC序列包括RV64I指令或者压缩指令，但是不包括加载、存储、向后跳转、向后分支、JALR、FENCE、以及SYSTEM指令。 <br> 3. LR/SC序列可以包含向后跳转的retry重试。<br>  4. SC指令的地址必须与同一个CPU执行的最新LR的有效地址和数据大小相同。| 
| 262  | 14.2章 | - |  如果在LR和SC序列中发生了进程切换，那么LR/SC还能成功吗? <br> <br> 目前不少RISC-V芯片采用类似arm的exclusive monitor的方式，那么在异常返回时，RTL可以清除local监视器。一个进程的切换，必定发生了一次时钟中断。中断也是异常的一种。所以，这样就可以保证进程切换时，LR申请的reservation set被作废了。 <br> <br> 另外还可以采用软件方式来清除local监视器。例如最新的Linux内核，在异常返回的时候， 对异常返回地址执行了一条SC指令（读异常返回地址的值，然后用SC指令往异常返回地址里写 刚才读回来的内容），这样就可以无效掉LR/SC组成的保留集，达到清除reservation set的目的. <br> <br> 在RISC-V架构手册卷1的第8.2章里有提到，使用SC指令对一块可以被抓破的内存进行写入 (也可以是任何地址。Linux内核异常返回时的做法是：读异常返回地址的值，然后用SC指令往异常返回地址里写 刚才读回来的内容)，用来无效掉已经加载的保留集，主要用途： <br> 1. 进程切换 <br> 2. 修改了VA->PA映射，并且这页面包含了一个活跃的保留集。|
